//created on: Aug 21, 2012
package uk.ac.imperial.dws04.Presage2Experiments.IPCon

//list any import classes here.
//java
import java.lang.String
import java.lang.Number;
import java.lang.Integer
import java.lang.Double
import java.lang.Object
import java.lang.Math
import java.util.UUID
import java.util.List
//IPCon
import uk.ac.imperial.dws04.Presage2Experiments.IPCon.IPConProtocol.Role
//drls
import uk.ac.imperial.dws04.Presage2Experiments.IPCon.IPCon_Institutional_Facts.*
//import uk.ac.imperial.dws04.Presage2Experiments.IPCon.IPConPowPer.*

//declare any global variables here
global org.apache.log4j.Logger logger

// fact indicating that if the person about to sync says no, there should be a revision after
declare PossibleAddRevision
	value : Object
	revision : Integer
	issue : String
	cluster : UUID
end

// fact indicating that if someone leaves, there may need to be a revision after
declare PossibleRemRevision
	value : Object
	revision : Integer
	issue : String
	cluster : UUID
end

rule "holdsAt for possibleAddRevision"
	when
		Sync( $agent : agent, $value : value, $revision : revision, $issue : issue, $cluster : cluster )
		Chosen( revision==$revision, $ballot : ballot, value==$value, issue==$issue, cluster==$cluster )
		// get the highest vote for each acceptors, compare FOR votes and NOTFOR votes
		Number( $forVotes : intValue ) from accumulate( 
								// find all the acceptors
								 $a : HasRole( role==Role.ACCEPTOR, revision==$revision, issue==$issue, cluster==$cluster ) and
								// that voted for the value
								$b : ReportedVote( agent==$a.agent, voteRevision==$revision, voteValue==$value, issue==$issue, cluster==$cluster ) and
								// and didn't vote since the one you just got
								not ReportedVote( agent==$a, voteRevision==$revision, voteBallot>$b.voteBallot, issue==$issue, cluster==$cluster )
								, count( $b ) )
		Number( $notForVotes : intValue, $notForVotes==$forVotes ) from accumulate( 
								// find all the acceptors
								$a1 : HasRole( role==Role.ACCEPTOR, revision==$revision, issue==$issue, cluster==$cluster ) and
								// that voted against the value
								$b1 : ReportedVote( agent==$a1.agent, voteRevision==$revision, voteValue!=$value, issue==$issue, cluster==$cluster ) and
								// and didn't vote since the one you just got
								not ReportedVote( agent==$a1, voteRevision==$revision, voteBallot>$b1.voteBallot, issue==$issue, cluster==$cluster )
								, count( $b1 ) )
		/*
		Number( $didntVotes : intValue, $forVotes <= $notForVotes+$didntVotes ) from accumulate(
								// find all the acceptors
								$a2 : HasRole( role==Role.ACCEPTOR, revision==$revision, issue==$issue, cluster==$cluster ) and
								// who didnt vote
								not ReportedVote( agent==$a2.agent, voteRevision==$revision, issue==$issue, cluster==$cluster )
								, count( $a2 ) )
		*/
	then
		logger.trace("Logically toggling possibleAddRevision");
		insertLogical( new PossibleAddRevision( $value, $revision, $issue, $cluster ) );
end


rule "holdsAt for possibleRemRevision"
	when
		// NOTE that this code is all reused from above except the following line...
		//Sync( $agent : agent, $value : value, $revision : revision, $issue : issue, $cluster : cluster )
		Chosen( $revision : revision, $ballot : ballot, $value : value, $issue : issue, $cluster : cluster )
		// get the highest vote for each acceptors, compare FOR votes and NOTFOR votes
		
		// find all acceptors
		$agents : List(size > 0) from accumulate(
								$a : HasRole( role==Role.ACCEPTOR, revision==$revision, issue==$issue, cluster==$cluster )
								, collectList( $a.getAgent() ) )
		
		Number( $forVotes : intValue ) from accumulate( 
								// that voted for the value
								$b : ReportedVote( agent memberOf $agents, voteRevision==$revision, voteValue==$value, issue==$issue, cluster==$cluster ) and
								// and didn't vote since the one you just got
								not ReportedVote( agent memberOf $agents, voteRevision==$revision, voteBallot>$b.voteBallot, issue==$issue, cluster==$cluster )
								, count( $b ) )
		Number( $notForVotes : intValue, $forVotes==$notForVotes ) from accumulate(
								// that voted against the value
								$b1 : ReportedVote( agent memberOf $agents, voteRevision==$revision, voteValue!=$value, issue==$issue, cluster==$cluster ) and 
								// and didn't vote since the one you just got
								not ReportedVote( agent memberOf $agents, voteRevision==$revision, voteBallot>$b1.voteBallot, issue==$issue, cluster==$cluster )
								, count( $b1 ) ) //and
		/*
		Number( $didntVotes : intValue, $forVotes <= $notForVotes+$didntVotes ) from accumulate(
								// find all the acceptors
								$a2 : HasRole( role==Role.ACCEPTOR, revision==$revision, issue==$issue, cluster==$cluster ) and
								// who didnt vote
								not ReportedVote( agent==$a2.agent, voteRevision==$revision, issue==$issue, cluster==$cluster )
								, count( $a2 ) )
								*/
	then
		logger.trace("Logically toggling possibleRemRevision");
		insertLogical( new PossibleRemRevision( $value, $revision, $issue, $cluster ) );
end


declare QuorumSize
	quorumSize : Integer
	revision : Integer
	issue : String
	cluster : UUID
end

rule "create new quorumsize fact"
	no-loop
	when
		HasRole( $revision : revision, $issue : issue, $cluster : cluster )
		not QuorumSize( revision==$revision, issue==$issue, cluster==$cluster )
		
	then
		insert( new QuorumSize( 0, $revision, $issue, $cluster ) );
end

rule "update quorumsize"
// FIXME TODO work out how to do this properly
	no-loop
	when
		$q : QuorumSize( $revision : revision, $issue : issue, $cluster : cluster )
		$acceptors : List( size >0 ) from accumulate( 
								// find all the acceptors
								$a : HasRole( role==Role.ACCEPTOR, revision==$revision, issue==$issue, cluster==$cluster )
								, collectList( $a.getAgent() ) )
		$syncs : Number( ) from accumulate(
								// find all the agents being synched
								$b : Sync( agent memberOf $acceptors, revision==$revision, issue==$issue, cluster==$cluster )
								, count( $b ) )
		$needToSyncs : List( ) from accumulate(
								// find all the agents that need to be synched
								$c : NeedToSync( agent memberOf $acceptors, revision==$revision, issue==$issue, cluster==$cluster )
								, collectList( $c ) )
	then
		/* logger.trace("0");
		Integer acc = $acceptors.size();
		double half = acc/2; logger.trace("1");
		half = java.lang.Math.floor( half ); logger.trace("2");
		Double floor = (Double)half; logger.trace("3");
		Integer newQS = floor.intValue() + 1; logger.trace("4");
		Integer newQSadjusted = newQS - $syncs.size() - $needToSyncs.size(); logger.trace("5");*/
		//Integer syncSize = $syncs.intValue();
		//Integer needToSyncSize = $needToSyncs.size();
		//logger.trace("BaseQS:" + (((Double)(java.lang.Math.floor( $acceptors.size() / 2 ) )).intValue()+1) + " / Syncs:" + syncSize + " / NeedToSyncs:" + needToSyncSize);
		modify($q) {
			//setQuorumSize( newQSadjusted );
			setQuorumSize( ((Double)(java.lang.Math.floor( $acceptors.size() / 2 ) )).intValue()+1 - $syncs.intValue() - $needToSyncs.size()  );
		};
		logger.trace("Updating quorumsize: " + $q);
end


/*
query "quorumSize"( Integer $revision, String $issue, UUID $cluster)
	$acceptors : Integer( ) from accumulate( 
								// find all the acceptors
								$a : HasRole( role==Role.ACCEPTOR, revision==$revision, issue==$issue, cluster==$cluster )
								, count( $a ) )
end
*/