//created on: Aug 21, 2012
package uk.ac.imperial.dws04.Presage2Experiments.IPCon

//list any import classes here.
// java
import java.util.List
import java.lang.Math
import java.lang.Double
import java.lang.String
import java.lang.Integer
import java.lang.Object
import java.util.UUID

//other drls files
import uk.ac.imperial.dws04.Presage2Experiments.IPCon.IPCon_Institutional_Facts.*
import uk.ac.imperial.dws04.Presage2Experiments.IPCon.IPConPowPer.*
import uk.ac.imperial.dws04.Presage2Experiments.IPCon.IPConUtils.*
import uk.ac.imperial.dws04.Presage2Experiments.IPCon.IPCon.*

// my presage2
import uk.ac.imperial.dws04.Presage2Experiments.IPCon.actions.*
import uk.ac.imperial.dws04.Presage2Experiments.IPCon.IPConProtocol.Role

//declare any global variables here
global org.apache.log4j.Logger logger
global Object IPCNV_val

// obligation

declare Obligation
	agent : IPConAgent
	action : IPConAction
end


rule "holdsAt for obligation to prepare"
// if you have permission, a value has been proposed, and a pre_vote doesn't exist already
    when
        //PreparePer( $agent : agent, $revision : revision, $issue : issue, $cluster : cluster )
        Permission( $agent : agent, $action : action )
        Prepare1A( agent==$agent, $revision : revision, $issue : issue, $cluster : cluster ) from $action
        Proposed( revision==$revision, issue==$issue, cluster==$cluster )
        not Pre_Vote( revision==$revision, issue==$issue, cluster==$cluster )
    then
    	//$ballot = Integer.NaN; // FIXME todo need to work out how to handle this...
    	Prepare1A $prepare = new Prepare1A( $agent, $revision, null, $issue, $cluster );
    	logger.trace("Logically toggling obligation to " + $prepare );
        insertLogical( new Obligation( $agent, $prepare ) ); 
end

rule "holdsAt for obligation to respond"
// if you haven't responded when you have permission to do so, and have voted, you must respond
// FIXME TODO possibly also send an indicator if you've responded higher to help the leader
	when
		//ResponsePer( $agent : agent, $voteRevision : voteRevision, $voteBallot : voteBallot, $voteValue : voteValue, $revision : revision, $ballot : ballot, $issue : issue, $cluster : cluster )
        Permission( $agent : agent, $action : action )
        Response1B( agent==$agent, $voteRevision : voteRevision, $voteBallot : voteBallot, $voteValue : voteValue, $revision : revision, $ballot : ballot, $issue : issue, $cluster : cluster ) from $action
		Voted( agent==$agent, revision==$voteRevision, ballot==$voteBallot, value==$voteValue, issue==$issue, cluster==$cluster )
		not ReportedVote( agent==$agent, revision==$voteRevision, ballot==$voteBallot, voteValue==$voteValue, revision==$revision, ballot==$ballot, issue==$issue, cluster==$cluster )
	then
		Response1B $response = new Response1B( $agent, $voteRevision, $voteBallot, $voteValue, $revision, $ballot, $issue, $cluster );
		logger.trace("Logically toggling obligation for " + $agent + "  to " + $response );
        insertLogical( new Obligation( $agent, $response ) );
end

rule "holdsAt for obligation to submit"
// if you have permission (which is pretty explicitly done) and haven't yet, you must
	when
		//SubmitPer( $agent : agent, $revision : revision, $ballot : ballot, $value : value, $issue : issue, $cluster : cluster )
        Permission( $agent : agent, $action : action )
        Submit2A( agent==$agent, $revision : revision, $ballot : ballot, $value : value, $issue : issue, $cluster : cluster ) from $action
		not Open_Vote( revision==$revision, ballot==$ballot, value==$value, issue==$issue, cluster==$cluster )
	then
		Submit2A $submit = new Submit2A( $agent, $revision, $ballot, $value, $issue, $cluster );
		logger.trace("Logically toggling obligation for " + $agent + "  to " + $submit );
        insertLogical( new Obligation( $agent, $submit ) );
end

rule "initiates for obligation to revise on leaveCluster"
// if an agent leaves when they are an acceptor and voted and you have a permission to revise and there is a possRemRev
	when
		LeaveCluster( $agent : agent, $cluster : cluster )
		//FIXME TODO check that this will actually work as the role will be modified by the remrole...
		// it won't...
		HasRole( role==Role.ACCEPTOR, agent==$agent, $revision : revision, $issue : issue, cluster==$cluster )
		//RevisePer( $leader : agent, revision==$revision, issue==$issue, cluster==$cluster )
        Permission( $leader : agent, $action : action )
        Revise( agent==$leader, oldRevision==$revision, issue==$issue, cluster==$cluster ) from $action
		PossibleRemRevision( $value : value, revision==$revision, issue==$issue, cluster==$cluster )
		ReportedVote( agent==$agent, voteRevision==$revision, voteValue==$value, revision==$revision, issue==$issue, cluster==$cluster )
	then
		Revise $revise = new Revise( $leader, $revision, $issue, $cluster );
		logger.trace("LeaveCluster inserted obligation for " + $leader + "  to " + $revise );
        insert( new Obligation( $leader, $revise ) ); 
end

 rule "initiates for obligation to revise on remRole"
// if an agent leaves when they are an acceptor and voted and you have a permission to revise and there is a possRemRev
	when
		RemRole( $leader : leader, $agent : agent, role==Role.ACCEPTOR, $revision : revision, $issue : issue, $cluster : cluster )
		//FIXME TODO check that this will actually work as the permission will be modified by the remrole...
		// FIXME TODO it doesn't :P Also should be pow...
		//RemRolePer( leader==$leader, agent==$agent, role==Role.ACCEPTOR, revision==$revision, issue==$issue, cluster==$cluster )
        Permission( agent==$leader, $action : action )
        RemRole( leader==$leader, agent==$agent, role==Role.ACCEPTOR, revision==$revision, issue==$issue, cluster==$cluster ) from $action
		//HasRole( role==Role.ACCEPTOR, agent==$agent, revision==$revision, issue==$issue, cluster==$cluster )
		//RevisePer( agent==$leader, revision==$revision, issue==$issue, cluster==$cluster )
        Permission( agent==$leader, $revAction : action )
        Revise( agent==$leader, oldRevision==$revision, issue==$issue, cluster==$cluster ) from $revAction
		PossibleRemRevision( $value : value, revision==$revision, issue==$issue, cluster==$cluster )
		ReportedVote( agent==$agent, voteRevision==$revision, voteValue==$value, revision==$revision, issue==$issue, cluster==$cluster )
	then
		Revise $revise = new Revise( $leader, $revision, $issue, $cluster );
		logger.trace("RemRole inserted obligation for " + $leader + " to " + $revise );
        insert( new Obligation( $leader, $revise ) ); 
end

rule "revise terminates obligation to revise"
// TODO will this work ? :S If it does, how about more general Action terminates obligation to Action ?
	no-loop
	when
		$revise : Revise( $agent : agent, $revision : oldRevision, $issue : issue, $cluster : cluster )
		$obl : Obligation( agent==$agent, action==$revise )
	then
		logger.trace("Revise retracted obligation for " + $agent + " to " + $revise );
        retract( $obl );
end

rule "holdsAt for obligation to syncReq"
// if you have permission, you must syncReq (syncreqper covers all the other requirements)
	when
		//SyncReqPer( $leader : leader, $agent : agent, $value : value, $revision : revision, $issue : issue, $cluster : cluster )
        Permission( $leader : agent, $action : action )
        SyncReq( leader==$leader, $agent : agent, $value : value, $revision : revision, $issue : issue, $cluster : cluster ) from $action
	then
		SyncReq $syncReq = new SyncReq( $leader, $agent, $value, $revision, $issue, $cluster );
		logger.trace("Logically toggling obligation for " + $leader + " to " + $syncReq );
        insertLogical( new Obligation( $leader, $syncReq ) );
end

rule "syncAck no initiates obligation to revise"
// if syncAck is no and agent had power to say so and leader has permission to revise and possibleAddRevision, leader must revise
	when
		//$answer==null 
		//SyncAckPow( $agent : agent, $answer : value, $revision : revision, $issue : issue, $cluster : cluster )
        //Power( $agent : agent, $actionPow : action )
        //SyncAck( agent==$agent, $answer : value, $revision : revision, $issue : issue, $cluster : cluster ) from $actionPow
		//SyncAck( agent==$agent, value==$answer, $answer==IPCNV_val, revision==$revision, issue==$issue, cluster==$cluster )
		SyncNo( $agent : agent, $revision : revision, $issue : issue, $cluster : cluster )
		//RevisePer( $leader : agent, revision==$revision, issue==$issue, cluster==$cluster )
        Permission( $leader : agent, $actionPer : action )
        $rev : Revise( agent==$leader, oldRevision==$revision, issue==$issue, cluster==$cluster ) from $actionPer
		PossibleAddRevision( /*value!=$answer,*/ revision==$revision, issue==$issue, cluster==$cluster )
		not Obligation( agent==$leader, action==$rev )
	then
		Revise $revise = new Revise( $leader, $revision, $issue, $cluster );
		logger.trace("SyncAck inserted obligation for " + $leader + " to " + $revise );
        insert( new Obligation( $leader, $revise ) ); 
end

rule "holdsAt for obligation to syncack"
// if you can, you must
	when
		// FIXME TODO left out value since it can be one of 2 (the correct one, or null)
		//SyncAckPer( $agent : agent, $revision : revision, $issue : issue, $cluster : cluster )
        Permission( $agent : agent, $action : action )
        SyncAck( agent==$agent, $revision : revision, $issue : issue, $cluster : cluster ) from $action
		Sync( agent==$agent, revision==$revision, issue==$issue, cluster==$cluster )
	then
		//$answer = Integer.NaN; //FIXME TODO need to work out how to handle this...
		SyncAck $syncAck = new SyncAck( $agent, null, $revision, $issue, $cluster );
		logger.trace("Sync logically toggling obligation for " + $agent + " to " + $syncAck );
        insertLogical( new Obligation( $agent, $syncAck ) );
end

rule "Generic obligation retraction"
	when
		$agent : IPConAgent( )
		$action : IPConAction( )
		$obl : Obligation( agent==$agent, action==$action ) 
	then
		logger.trace("Retracted obligation: " + $obl);
		retract( $obl );
end	 

query "agentObligations" (IPConAgent $agent)
	Obligation( agent==$agent, $action : action )
end

query "getObligations"
	Obligation( $agent : agent, $action : action )
end
